{"mappings":"4PAAA,I,IAAAA,EAAAC,EAAA,S,iVCCA,IAAAC,EAAAD,EAAA,S,8CAuDA,MAAME,EAA2BC,EAAOC,MAAMH,EAAAI,2BAA2BC,KAAK,GAMxE,MAAOC,EAUTC,cARAC,KAAAC,IAAM,qCAyDCD,KAAAE,QAAU,KACb,IAAIF,KAAKG,SAASC,SAAQC,GAAKL,KAAKM,WAAWD,KAC/C,MAAME,EAASP,KAAKQ,QAChBD,GACAA,EAAOE,QAEXT,KAAKQ,QAAU,IAAI,EA4FfR,KAAAM,WAAcI,IAClBV,KAAKG,QAAUH,KAAKG,QAAQQ,QAAON,GAAKA,GAAKK,IAC7CE,OAAOC,cAAcH,EAAM,EAGvBV,KAAAc,uCAA0CC,GAAsEA,EAAaC,KAAIC,IAC9H,CACHC,UAAaD,EAAEC,UAAUC,WACzBC,aAAgBH,EAAEI,KAAKL,KAAIM,IAChB,CACHC,QAASD,EAAEE,OAAOL,WAClBM,OAAQH,EAAEI,SACVC,SAAUL,EAAEM,eAGpBC,KAAQjB,OAAOkB,KAAKC,OAAOC,gBAAgBf,EAAEY,WA+C7C7B,KAAAiC,oBAAuBJ,I,UAC3B,GAAiB,aAAbA,EAAKK,KACLlC,KAAKmC,aAAc,EACdN,EAAKO,QACNpC,KAAKqC,YAAa,GACA,QAAdC,EAAAT,EAAKU,iBAAS,IAAAD,OAAA,EAAAA,EAAEE,aAChBxC,KAAKyC,WAAa,IAAI,EAAAjD,EAAAkD,WAAUb,EAAKU,UAAUC,kBAGpD,GAAI,CAAC,kBAAmB,wBAAwBG,SAASd,EAAKK,MAAO,CACxE,MAAMU,EAA4C,QAApBC,EAAAhB,EAAKiB,uBAAe,IAAAD,OAAA,EAAAA,EAAEE,WAChDH,GAAyBA,KAAyB5C,KAAKgD,uBACnDnB,EAAKO,MACLpC,KAAKiD,0BAA0BL,GAAyB,IAAIM,MAAMrB,EAAKO,OAEvEpC,KAAKgD,qBAAqBJ,GAAyBf,EAAKiB,iBAAmB,K,MAGhF,GAAiB,mBAAbjB,EAAKK,KAA2B,CACvC,MAAMiB,EAA4C,QAApBC,EAAAvB,EAAKwB,uBAAe,IAAAD,OAAA,EAAAA,EAAEL,WAChDI,GAAyBA,KAAyBnD,KAAKgD,uBACnDnB,EAAKO,MACLpC,KAAKiD,0BAA0BE,GAAyB,IAAID,MAAMrB,EAAKO,OAEvEpC,KAAKgD,qBAAqBG,GAAyBtB,EAAKwB,iBAAmB,K,GAxOvFrD,KAAKqC,YAAa,EAClBrC,KAAKgD,qBAAuB,GAC5BhD,KAAKiD,0BAA4B,GACjCjD,KAAKG,QAAU,GACfH,KAAKQ,QAAU,KACfR,KAAKmC,aAAc,EACnBnC,KAAKyC,WAAa,KAElB7B,OAAO0C,iBAAiB,WAAYC,IAChCvD,KAAKiC,oBAAoBsB,EAAE1B,KAA4B,G,CAI/D2B,cAAcvD,GACV,IACID,KAAKC,IAAMA,GAAOD,KAAKC,IACvB,MAAMwD,EAASC,mBAAmB9C,OAAO+C,SAASF,QAC5CG,EAAa,GAAG5D,KAAKC,sBAAsBwD,IAGjD,GAFAzD,KAAKmC,aAAc,EACnBnC,KAAKQ,QAAUI,OAAOiD,KAAKD,EAAY,iBAAiBH,IAAU,yDAC7DzD,KAAKQ,QAEN,MADAR,KAAKmC,aAAc,EACb,IAAIe,MAAM,+BASpB,OAPAlD,KAAKG,QAAQ2D,KAAKlD,OAAOmD,aAAY,KAC7B/D,KAAKQ,QAASwD,OACdhE,KAAKE,UACEF,KAAKQ,SACZR,KAAKQ,QAAQyD,YAAY,CAAC/B,KAAM,aAAclC,KAAKC,IAAI,GAE5D,MACI,IAAIiE,SAAmB,CAACC,EAASC,KACpC,MAAM1D,EAAQE,OAAOmD,aAAY,KACzB/D,KAAKqC,YAAcrC,KAAKyC,YACxBzC,KAAKM,WAAWI,GAChByD,EAAQnE,KAAKyC,aACLzC,KAAKqC,YAAerC,KAAKmC,cACjCnC,KAAKM,WAAWI,GAChB0D,EAAO,IAAIlB,MAAM,gC,GAEtB,KACHlD,KAAKG,QAAQ2D,KAAKpD,EAAM,G,CAE9B,MAAO0B,GACL,MAAMA,C,EAaPoB,sBAAsBa,GACzBrE,KAAKsE,sBAAsB,CAACD,IAC5B,IACI,OAAOrE,KAAKuE,mBAAmBF,E,CACjC,MAAOjC,GACL,MAAMA,C,EAIPoB,0BAA0BgB,GAC7BxE,KAAKsE,sBAAsBE,GAC3B,IACI,OAAON,QAAQO,IAAID,EAAaxD,KAAIqD,GACzBrE,KAAKuE,mBAAmBF,K,CAErC,MAAOjC,GACL,MAAMA,C,EAIPoB,sBACHa,EACAK,EACAC,GAEA,IACI,MAAMpE,EAASP,KAAKQ,QACpB,IAAKD,EAAQ,MAAM,IAAI2C,MAAM,iBAE7B,MAAMN,GAAwB,EAAAgC,EAAAC,MAC9B7E,KAAKgD,qBAAqBJ,GAAyB,KACnD,MAAMkC,EAAUH,EAAUA,EAAQG,aAAUC,EAE5C,GAAID,GAAWA,EAASE,OAAS,EAC7B,OAAO,IAAId,SAA8B,CAACC,EAASC,KAC/CpE,KAAKuE,mBAAmBF,EAAazB,GAAuBqC,MAAKC,IAC7DlF,KAAKgD,qBAAqBJ,GAAyB,MACnDkC,aAAO,EAAPA,EAASE,SAAUE,EAAkBC,eAAeL,GACpDvE,EAAO0D,YAAY,CACf/B,KAAM,uBAAwBkD,qBAAsB,C,sBAChDxC,EACAyC,qBAAsBH,EAAkBI,WAAW3E,QAAO4E,GAAsB,MAAhBA,EAAGC,YAAmBxE,KAAIuE,IAC/E,CACH/D,OAAU+D,EAAG/C,UAAUrB,WACvBqE,UAAaD,EAAGC,UAAWC,SAAS,gBAIjDzF,KAAKC,KACR,MAAMS,EAAQE,OAAOmD,aAAY,KAC7B,MAAM2B,EAAqB1F,KAAKgD,qBAAqBJ,GAC/C+C,EAA0B3F,KAAKiD,0BAA0BL,GACrC,MAAtB8C,GAAyD,MAA3BC,IAC9B3F,KAAKM,WAAWI,GAChBgF,GAAsBvB,EAAQuB,EAAmBF,WACjDG,GAA2BvB,EAAOuB,G,GAEvC,KACH3F,KAAKG,QAAQ2D,KAAKpD,EAAM,IACzBkF,OAAOxD,IAEN,MADAgC,EAAOhC,GACDA,CAAK,GACb,IAEH,CACH,MAAMrB,EAAef,KAAKc,uCAAuCuD,EAAYtD,cAC7E,OAAO,IAAImD,SAA8B,CAACC,EAASC,KAC/C7D,EAAO0D,YAAY,CACf/B,KAAM,kBACNY,gBAAiB,C,aAAE/B,E,sBAAc6B,IAClC5C,KAAKC,KACR,MAAMS,EAAQE,OAAOmD,aAAY,KAC7B,MAAM2B,EAAqB1F,KAAKgD,qBAAqBJ,GAC/C+C,EAA0B3F,KAAKiD,0BAA0BL,GACrC,MAAtB8C,GAAyD,MAA3BC,IAC9B3F,KAAKM,WAAWI,GAChBgF,GAAsBvB,EAAQuB,EAAmBF,WACjDG,GAA2BvB,EAAOuB,G,GAEvC,KACH3F,KAAKG,QAAQ2D,KAAKpD,EAAM,G,EAGlC,MAAO0B,GACL,MAAMA,C,EAwBNyD,iBAAiBH,GACrB,IAAII,EAAUtG,EAAAuG,QAAQC,KAAKtG,EAAOsG,KAAKC,WAAWD,KAAKpF,OAAOsF,KAAKR,EAAmBI,UAAWK,GAAKA,EAAEC,WAAW,OACnH,OAAO5G,EAAA6G,YAAYC,SACfR,EACAS,MAAMP,KAAK,CAAChB,OAAQc,EAAQU,OAAOC,wBAAwB,CAACC,EAAIzF,KAC5D,IAAI0F,EAAgBjB,EAAmBJ,WAAWsB,MAAKC,GAAKA,EAAErF,QAAUsE,EAAQgB,YAAY7F,GAAGE,aAC/F,OAAO4F,EAAAC,GAAKC,OAAON,EACbjH,EAAOsG,KAAKC,WAAWD,KAAKpF,OAAOsF,KAAKS,EAAcnB,YAAYW,GAAKA,EAAEC,WAAW,MACpF3G,EACL,I,CAKL6E,sBAAsBE,GAC1BA,EAAapE,SAAQiE,IACjB,GAAIA,EAAYiB,WAAW4B,MAAKL,GAAoB,MAAfA,EAAErB,YACnC,MAAM,IAAItC,MAAM,4CAA4C,G,CAKhEqB,mBAAmBF,EAA0BzB,GAAwB,EAAAgC,EAAAC,OACzE,MAAMtE,EAASP,KAAKQ,QACpB,IAAKD,EAAQ,MAAM,IAAI2C,MAAM,iBAE7B,MAAMnC,EAAef,KAAKc,uCAAuCuD,EAAYtD,cAE7E,OADAf,KAAKgD,qBAAqBJ,GAAyB,KAC5C,IAAIsB,SAAqB,CAACC,EAASC,KACtC7D,EAAO0D,YAAY,CAAC/B,KAAM,kBAAmBmB,gBAAiB,C,aAAEtC,E,sBAAc6B,IAA0B5C,KAAKC,KAC7G,MAAMS,EAAQE,OAAOmD,aAAY,KAC7B,MAAM2B,EAAqB1F,KAAKgD,qBAAqBJ,GAC/C+C,EAA0B3F,KAAKiD,0BAA0BL,GACrC,MAAtB8C,GAAyD,MAA3BC,IAC9B3F,KAAKM,WAAWI,GAChBgF,GAAsBvB,EAAQnE,KAAK6F,iBAAiBH,IACpDC,GAA4BvB,EAAOuB,G,GAExC,KACH3F,KAAKG,QAAQ2D,KAAKpD,EAAM,G","sources":["node_modules/@strike-protocols/solana-wallet-adapter/src/index.ts","node_modules/@strike-protocols/solana-wallet-adapter/src/strikewallet.ts"],"sourcesContent":["export * from './strikewallet';\n","\nimport {\n    Blockhash, Connection, Message,\n    PublicKey,\n    SIGNATURE_LENGTH_IN_BYTES, Signer, Transaction,\n    TransactionInstruction,\n    TransactionSignature\n} from \"@solana/web3.js\";\nimport bs58 from \"bs58\";\nimport {v4 as uuidv4} from \"uuid\";\n\n\ninterface Connected {\n    publicKey: PublicKey;\n}\n\ninterface SendTransaction {\n    identifier: string;\n    signature: TransactionSignature;\n}\n\ninterface SerializableSignaturePubkeyPair {\n    signature: string;\n    pubkey: string;\n}\n\ninterface SignTransaction {\n    identifier: string;\n    signatures: SerializableSignaturePubkeyPair[];\n    feePayer: string;\n    recentBlockhash: Blockhash;\n    message: string;\n}\n\ninterface StrikeWalletMessage {\n    type: 'connected' | 'sendTransaction' | 'signTransaction';\n    error?: string;\n    connected?: Connected;\n    sendTransaction?: SendTransaction;\n    signTransaction?: SignTransaction;\n}\n\ninterface PendingTransactions {\n    [hash: string]: SendTransaction | SignTransaction | null\n}\n\ninterface PendingTransactionErrors {\n    [hash: string]: Error | null\n}\n\ninterface SerializableInstruction {\n    data: string,\n    accountMetas: {address: string, signer: boolean, writable: boolean}[],\n    programId: string\n}\n\nconst DEFAULT_SIGNATURE_BUFFER = Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0)\n\nexport interface SignerOptions {\n    signers?: Signer[];\n}\n\nexport class StrikeWallet {\n    isLoggedIn: boolean;\n    url = 'https://wallet.strikeprotocols.com';\n    private _pendingTransactions: PendingTransactions;\n    private _pendingTransactionErrors: PendingTransactionErrors;\n    private _timers: number[];\n    private _wallet: Window | null;\n    private _connecting: boolean;\n    private _publicKey: PublicKey | null;\n\n    constructor() {\n        this.isLoggedIn = false\n        this._pendingTransactions = {}\n        this._pendingTransactionErrors = {}\n        this._timers = []\n        this._wallet = null;\n        this._connecting = false\n        this._publicKey = null\n\n        window.addEventListener(\"message\", (e) => {\n            this.handleWalletMessage(e.data as StrikeWalletMessage)\n        })\n    }\n\n    async connect(url: string | null): Promise<PublicKey> {\n        try {\n            this.url = url || this.url\n            const origin = encodeURIComponent(window.location.origin);\n            const connectUrl = `${this.url}/connect?origin=${origin}`;\n            this._connecting = true\n            this._wallet = window.open(connectUrl, `strike-wallet-${origin}`, \"height=800,width=800,menubar=no,status=no,toolbar=no\");\n            if (!this._wallet) {\n                this._connecting = false\n                throw new Error(\"Unable to connect to wallet\")\n            }\n            this._timers.push(window.setInterval(() => {\n                if (this._wallet!.closed) {\n                    this.cleanUp();\n                } else if (this._wallet) {\n                    this._wallet.postMessage({type: 'heartbeat'}, this.url)\n                }\n            }, 100));\n            return new Promise<PublicKey>((resolve, reject) => {\n                const timer = window.setInterval(() => {\n                    if (this.isLoggedIn && this._publicKey) {\n                        this.clearTimer(timer);\n                        resolve(this._publicKey!)\n                    } else if (!this.isLoggedIn && !this._connecting) {\n                        this.clearTimer(timer);\n                        reject(new Error(\"Unable to connect to Strike\"))\n                    }\n                }, 100);\n                this._timers.push(timer)\n            })\n        } catch (error: any) {\n            throw error;\n        }\n    }\n\n    public cleanUp = () => {\n        [...this._timers].forEach(t => this.clearTimer(t));\n        const wallet = this._wallet;\n        if (wallet) {\n            wallet.close()\n        }\n        this._wallet = null\n    }\n\n    public async signTransaction(transaction: Transaction): Promise<Transaction> {\n        this.verifyCanSignRequests([transaction])\n        try {\n            return this.signOneTransaction(transaction);\n        } catch (error: any) {\n            throw error;\n        }\n    }\n\n    public async signAllTransactions(transactions: Transaction[]): Promise<Transaction[]> {\n        this.verifyCanSignRequests(transactions)\n        try {\n            return Promise.all(transactions.map(transaction => {\n                return this.signOneTransaction(transaction);\n            }))\n        } catch (error: any) {\n            throw error;\n        }\n    }\n\n    public async sendTransaction(\n        transaction: Transaction,\n        connection: Connection,\n        options?: SignerOptions,\n    ): Promise<TransactionSignature> {\n        try {\n            const wallet = this._wallet;\n            if (!wallet) throw new Error(\"Not Connected\");\n\n            const transactionIdentifier = uuidv4()\n            this._pendingTransactions[transactionIdentifier] = null;\n            const signers = options ? options.signers : undefined;\n\n            if (signers && signers!.length > 0) {\n                return new Promise<TransactionSignature>((resolve, reject) => {\n                    this.signOneTransaction(transaction, transactionIdentifier).then(walletTransaction => {\n                        this._pendingTransactions[transactionIdentifier] = null\n                        signers?.length && walletTransaction.partialSign(...signers);\n                        wallet.postMessage({\n                            type: \"sendFinalTransaction\", sendFinalTransaction: {\n                                transactionIdentifier,\n                                signaturePubkeyPairs: walletTransaction.signatures.filter(sp => sp.signature != null).map(sp => {\n                                    return {\n                                        'pubkey': sp.publicKey.toBase58(),\n                                        'signature': sp.signature!.toString('base64')\n                                    }\n                                })\n                            }\n                        }, this.url);\n                        const timer = window.setInterval(() => {\n                            const pendingTransaction = this._pendingTransactions[transactionIdentifier] as SendTransaction\n                            const pendingTransactionError = this._pendingTransactionErrors[transactionIdentifier]\n                            if (pendingTransaction != null || pendingTransactionError != null) {\n                                this.clearTimer(timer);\n                                pendingTransaction && resolve(pendingTransaction.signature)\n                                pendingTransactionError && reject(pendingTransactionError)\n                            }\n                        }, 100);\n                        this._timers.push(timer)\n                    }).catch((error) => {\n                        reject(error)\n                        throw error;\n                    })\n                })\n            } else {\n                const instructions = this.instructionsToSerializableInstructions(transaction.instructions)\n                return new Promise<TransactionSignature>((resolve, reject) => {\n                    wallet.postMessage({\n                        type: \"sendTransaction\",\n                        sendTransaction: { instructions, transactionIdentifier }\n                    }, this.url);\n                    const timer = window.setInterval(() => {\n                        const pendingTransaction = this._pendingTransactions[transactionIdentifier] as SendTransaction\n                        const pendingTransactionError = this._pendingTransactionErrors[transactionIdentifier]\n                        if (pendingTransaction != null || pendingTransactionError != null) {\n                            this.clearTimer(timer);\n                            pendingTransaction && resolve(pendingTransaction.signature)\n                            pendingTransactionError && reject(pendingTransactionError)\n                        }\n                    }, 100);\n                    this._timers.push(timer)\n                })\n            }\n        } catch (error) {\n            throw error;\n        }\n    }\n\n\n    private clearTimer = (timer: number) => {\n        this._timers = this._timers.filter(t => t != timer)\n        window.clearInterval(timer);\n    }\n\n    private instructionsToSerializableInstructions = (instructions: TransactionInstruction[]): SerializableInstruction[] => instructions.map(i => {\n        return {\n            'programId': i.programId.toBase58(),\n            'accountMetas': i.keys.map(k => {\n                return {\n                    address: k.pubkey.toBase58(),\n                    signer: k.isSigner,\n                    writable: k.isWritable,\n                }\n            }),\n            'data': window.btoa(String.fromCharCode(...i.data)),\n        }\n    })\n\n    private buildTransaction(pendingTransaction: SignTransaction): Transaction {\n        let message = Message.from(Buffer.from(Uint8Array.from(window.atob(pendingTransaction.message!), c => c.charCodeAt(0))))\n        return Transaction.populate(\n            message,\n            Array.from({length: message.header.numRequiredSignatures}, (_v, i) => {\n                let sigPubkeyPair = pendingTransaction.signatures.find(s => s.pubkey == message.accountKeys[i].toBase58())\n                return bs58.encode(sigPubkeyPair\n                    ? Buffer.from(Uint8Array.from(window.atob(sigPubkeyPair.signature), c => c.charCodeAt(0)))\n                    : DEFAULT_SIGNATURE_BUFFER\n                )\n            })\n        )\n    }\n\n    private verifyCanSignRequests(transactions: Transaction[]) {\n        transactions.forEach(transaction => {\n            if (transaction.signatures.some(s => s.signature != null)) {\n                throw new Error(\"Strike does not support this signing mode\")\n            }\n        })\n    }\n\n    private signOneTransaction(transaction: Transaction, transactionIdentifier = uuidv4()): Promise<Transaction> {\n        const wallet = this._wallet;\n        if (!wallet) throw new Error(\"Not Connected\");\n\n        const instructions = this.instructionsToSerializableInstructions(transaction.instructions)\n        this._pendingTransactions[transactionIdentifier] = null;\n        return new Promise<Transaction>((resolve, reject) => {\n            wallet.postMessage({type: \"signTransaction\", signTransaction: { instructions, transactionIdentifier }}, this.url);\n            const timer = window.setInterval(() => {\n                const pendingTransaction = this._pendingTransactions[transactionIdentifier] as SignTransaction\n                const pendingTransactionError = this._pendingTransactionErrors[transactionIdentifier]\n                if (pendingTransaction != null || pendingTransactionError != null) {\n                    this.clearTimer(timer)\n                    pendingTransaction && resolve(this.buildTransaction(pendingTransaction))\n                    pendingTransactionError &&  reject(pendingTransactionError)\n                }\n            }, 100);\n            this._timers.push(timer)\n        });\n    }\n\n    private handleWalletMessage = (data: StrikeWalletMessage) => {\n        if (data.type == \"connected\") {\n            this._connecting = false;\n            if (!data.error) {\n                this.isLoggedIn = true;\n                if (data.connected?.publicKey) {\n                    this._publicKey = new PublicKey(data.connected.publicKey);\n                }\n            }\n        } else if ([\"sendTransaction\", \"sendFinalTransaction\"].includes(data.type)) {\n            const transactionIdentifier = data.sendTransaction?.identifier\n            if (transactionIdentifier && transactionIdentifier in this._pendingTransactions) {\n                if (data.error) {\n                    this._pendingTransactionErrors[transactionIdentifier] = new Error(data.error);\n                } else {\n                    this._pendingTransactions[transactionIdentifier] = data.sendTransaction || null\n                }\n            }\n        } else if (data.type == \"signTransaction\") {\n            const transactionIdentifier = data.signTransaction?.identifier\n            if (transactionIdentifier && transactionIdentifier in this._pendingTransactions) {\n                if (data.error) {\n                    this._pendingTransactionErrors[transactionIdentifier] = new Error(data.error);\n                } else {\n                    this._pendingTransactions[transactionIdentifier] = data.signTransaction || null\n                }\n            }\n        }\n    }\n}\n"],"names":["$6h0G7","parcelRequire","$gNDby","$4a4fa3b313f77edd$var$DEFAULT_SIGNATURE_BUFFER","$4a4fa3b313f77edd$require$Buffer","alloc","SIGNATURE_LENGTH_IN_BYTES","fill","$4a4fa3b313f77edd$export$117c1ba5248942d0","constructor","this","url","cleanUp","_timers","forEach","t","clearTimer","wallet","_wallet","close","timer","filter","window","clearInterval","instructionsToSerializableInstructions","instructions","map","i","programId","toBase58","accountMetas","keys","k","address","pubkey","signer","isSigner","writable","isWritable","data","btoa","String","fromCharCode","handleWalletMessage","type","_connecting","error","isLoggedIn","_a","connected","publicKey","_publicKey","PublicKey","includes","transactionIdentifier","_b","sendTransaction","identifier","_pendingTransactions","_pendingTransactionErrors","Error","transactionIdentifier1","_c","signTransaction","addEventListener","e","async","origin","encodeURIComponent","location","connectUrl","open","push","setInterval","closed","postMessage","Promise","resolve","reject","transaction","verifyCanSignRequests","signOneTransaction","transactions","all","connection","options","$4Xk08","v4","signers","undefined","length","then","walletTransaction","partialSign","sendFinalTransaction","signaturePubkeyPairs","signatures","sp","signature","toString","pendingTransaction","pendingTransactionError","catch","buildTransaction","message","Message","from","Uint8Array","atob","c","charCodeAt","Transaction","populate","Array","header","numRequiredSignatures","_v","sigPubkeyPair","find","s","accountKeys","$parcel$interopDefault","$bYkMz","encode","some"],"version":3,"file":"esm.3ee4d3e6.js.map"}