function n(n){return n&&n.__esModule?n.default:n}var t=("undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{}).parcelRequire1f5d;t.register("eDOdq",(function(n,i){var e,s,r=t("6h0G7");e=n.exports,s=r,Object.keys(s).forEach((function(n){"default"===n||"__esModule"===n||e.hasOwnProperty(n)||Object.defineProperty(e,n,{enumerable:!0,get:function(){return s[n]}})}))})),t.register("6h0G7",(function(i,e){var s,r,o,a;s=i.exports,r="StrikeWallet",o=()=>g,Object.defineProperty(s,r,{get:o,set:a,enumerable:!0,configurable:!0});var l=t("gNDby"),c=t("bYkMz"),h=t("4Xk08"),u=t("6ZWSX").Buffer;const d=u.alloc(l.SIGNATURE_LENGTH_IN_BYTES).fill(0);class g{constructor(){this.url="https://wallet.strikeprotocols.com",this.cleanUp=()=>{[...this._timers].forEach((n=>this.clearTimer(n)));const n=this._wallet;n&&n.close(),this._wallet=null},this.clearTimer=n=>{this._timers=this._timers.filter((t=>t!=n)),window.clearInterval(n)},this.instructionsToSerializableInstructions=n=>n.map((n=>({programId:n.programId.toBase58(),accountMetas:n.keys.map((n=>({address:n.pubkey.toBase58(),signer:n.isSigner,writable:n.isWritable}))),data:window.btoa(String.fromCharCode(...n.data))}))),this.handleWalletMessage=n=>{var t,i,e;if("connected"==n.type)this._connecting=!1,n.error||(this.isLoggedIn=!0,(null===(t=n.connected)||void 0===t?void 0:t.publicKey)&&(this._publicKey=new(0,l.PublicKey)(n.connected.publicKey)));else if(["sendTransaction","sendFinalTransaction"].includes(n.type)){const t=null===(i=n.sendTransaction)||void 0===i?void 0:i.identifier;t&&t in this._pendingTransactions&&(n.error?this._pendingTransactionErrors[t]=new Error(n.error):this._pendingTransactions[t]=n.sendTransaction||null)}else if("signTransaction"==n.type){const t=null===(e=n.signTransaction)||void 0===e?void 0:e.identifier;t&&t in this._pendingTransactions&&(n.error?this._pendingTransactionErrors[t]=new Error(n.error):this._pendingTransactions[t]=n.signTransaction||null)}},this.isLoggedIn=!1,this._pendingTransactions={},this._pendingTransactionErrors={},this._timers=[],this._wallet=null,this._connecting=!1,this._publicKey=null,window.addEventListener("message",(n=>{this.handleWalletMessage(n.data)}))}async connect(n){try{this.url=n||this.url;const t=encodeURIComponent(window.location.origin),i=`${this.url}/connect?origin=${t}`;if(this._connecting=!0,this._wallet=window.open(i,`strike-wallet-${t}`,"height=800,width=800,menubar=no,status=no,toolbar=no"),!this._wallet)throw this._connecting=!1,new Error("Unable to connect to wallet");return this._timers.push(window.setInterval((()=>{this._wallet.closed?this.cleanUp():this._wallet&&this._wallet.postMessage({type:"heartbeat"},this.url)}),100)),new Promise(((n,t)=>{const i=window.setInterval((()=>{this.isLoggedIn&&this._publicKey?(this.clearTimer(i),n(this._publicKey)):this.isLoggedIn||this._connecting||(this.clearTimer(i),t(new Error("Unable to connect to Strike")))}),100);this._timers.push(i)}))}catch(n){throw n}}async signTransaction(n){this.verifyCanSignRequests([n]);try{return this.signOneTransaction(n)}catch(n){throw n}}async signAllTransactions(n){this.verifyCanSignRequests(n);try{return Promise.all(n.map((n=>this.signOneTransaction(n))))}catch(n){throw n}}async sendTransaction(n,t,i){try{const t=this._wallet;if(!t)throw new Error("Not Connected");const e=(0,h.v4)();this._pendingTransactions[e]=null;const s=i?i.signers:void 0;if(s&&s.length>0)return new Promise(((i,r)=>{this.signOneTransaction(n,e).then((n=>{this._pendingTransactions[e]=null,(null==s?void 0:s.length)&&n.partialSign(...s),t.postMessage({type:"sendFinalTransaction",sendFinalTransaction:{transactionIdentifier:e,signaturePubkeyPairs:n.signatures.filter((n=>null!=n.signature)).map((n=>({pubkey:n.publicKey.toBase58(),signature:n.signature.toString("base64")})))}},this.url);const o=window.setInterval((()=>{const n=this._pendingTransactions[e],t=this._pendingTransactionErrors[e];null==n&&null==t||(this.clearTimer(o),n&&i(n.signature),t&&r(t))}),100);this._timers.push(o)})).catch((n=>{throw r(n),n}))}));{const i=this.instructionsToSerializableInstructions(n.instructions);return new Promise(((n,s)=>{t.postMessage({type:"sendTransaction",sendTransaction:{instructions:i,transactionIdentifier:e}},this.url);const r=window.setInterval((()=>{const t=this._pendingTransactions[e],i=this._pendingTransactionErrors[e];null==t&&null==i||(this.clearTimer(r),t&&n(t.signature),i&&s(i))}),100);this._timers.push(r)}))}}catch(n){throw n}}buildTransaction(t){let i=l.Message.from(u.from(Uint8Array.from(window.atob(t.message),(n=>n.charCodeAt(0)))));return l.Transaction.populate(i,Array.from({length:i.header.numRequiredSignatures},((e,s)=>{let r=t.signatures.find((n=>n.pubkey==i.accountKeys[s].toBase58()));return n(c).encode(r?u.from(Uint8Array.from(window.atob(r.signature),(n=>n.charCodeAt(0)))):d)})))}verifyCanSignRequests(n){n.forEach((n=>{if(n.signatures.some((n=>null!=n.signature)))throw new Error("Strike does not support this signing mode")}))}signOneTransaction(n,t=(0,h.v4)()){const i=this._wallet;if(!i)throw new Error("Not Connected");const e=this.instructionsToSerializableInstructions(n.instructions);return this._pendingTransactions[t]=null,new Promise(((n,s)=>{i.postMessage({type:"signTransaction",signTransaction:{instructions:e,transactionIdentifier:t}},this.url);const r=window.setInterval((()=>{const i=this._pendingTransactions[t],e=this._pendingTransactionErrors[t];null==i&&null==e||(this.clearTimer(r),i&&n(this.buildTransaction(i)),e&&s(e))}),100);this._timers.push(r)}))}}}));
//# sourceMappingURL=esm.3ee4d3e6.js.map
